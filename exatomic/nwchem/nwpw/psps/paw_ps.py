# -*- coding: utf-8 -*-
# Copyright (c) 2015-2017, Exa Analytics Development Team
# Distributed under the terms of the Apache License 2.0
"""
Pseudized Output Editors
##########################
These parsing editors are targeted at parsing pseudized wave function and potential
data.
"""
import six
import pandas as pd
from exa.special import LazyFunction
from exa.tex import text_value_cleaner
from exa.core import Meta, Parser, DataFrame
from exatomic.nwchem.nwpw.psps.grid import scaled_logspace


class PAWOutputMeta(Meta):
    """Defines data objects for PAWOutput."""
    data = DataFrame
    info = dict
    grid = LazyFunction
    _descriptions = {'data': "Pseudized channel data",
                     'info': "Atom, charge, and core info",
                     'grid': "Grid information"}


class PAWOutput(six.with_metaclass(PAWOutputMeta, Parser)):
    """
    Parser for debug output files generated by NWChem's on-the-fly pseudopotential
    generation code.
    """
    _key_delims = (" Atom information :", " Logarithmic grid information ( r(i)=r0*pow(a,i) )",
                   " Compensation charge information :", " Paw potential information :",
                   " Basis information :", " Core information :")
    description = "Parser for 'El_paw' NWChem output files (El is an element sybol)."

    def _parse(self):
        """Identify and process the output file from text to data objects."""
        self.info = {}
        self.data = DataFrame()
        sections = self.find(*self._key_delims, text=False)
        for section, start in sections.items():
            if section == " Paw potential information :":
                self._key_subsection_parsers[section](start[0]+1, delnl=True)
            else:
                self._key_subsection_parsers[section](start[0]+1)

    def _parse_info_like(self, start, save=True):
        """Function to parse 'key delimiter value' lines of the output."""
        sep = ':' if ':' in self[start+1] else "="
        k = 0
        dct = {}
        for line in self[start:]:
            if sep not in line:
                k += 1
                if k == 2:
                    break
            else:
                key, value = line.split(sep)
                dct[key.strip()] = text_value_cleaner(value)
        if save:
            self.info.update(dct)
        else:
            return dct

    def _parse_grid(self, start):
        """Parse the arguments to the grid function."""
        grid = self._parse_info_like(start, save=False)
        self.grid = LazyFunction(scaled_logspace, grid['r0'], grid['a'], grid['N'])

    def _parse_paw(self, start, delnl=False):
        """Parse the PAW potential and basis information."""
        m = len(self.info)
        self._parse_info_like(start)
        n = len(self.info)
        k = start + n - m + 2
        l = 0
        for line in self[k:]:
            if line == "":
                break
            l += 1
        df = self[k:k+l].to_data(delim_whitespace=True)
        if delnl:
            del df['nl']
        self._merge_df(df)

    def _merge_df(self, df):
        if len(self.data) == 0:
            self.data = df
        else:
            self.data = pd.concat((self.data, df), axis=1)
        if 'nl' in self.data.columns:
            self.data['nl'] = self.data['nl'].str.upper()

    def __init__(self, *args, **kwargs):
        super(PAWOutput, self).__init__(*args, **kwargs)
        self._key_parsers = (self._parse_info_like, self._parse_grid,
                             self._parse_info_like, self._parse_paw,
                             self._parse_paw, self._parse_info_like)
        self._key_subsection_parsers = dict(zip(self._key_delims, self._key_parsers))
