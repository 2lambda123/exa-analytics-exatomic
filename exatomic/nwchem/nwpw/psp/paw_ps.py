# -*- coding: utf-8 -*-
# Copyright (c) 2015-2017, Exa Analytics Development Team
# Distributed under the terms of the Apache License 2.0
"""
Pseudized Output Editors
##########################
These parsing editors are targeted at parsing pseudized wave function and potential
data.
"""
import six
import pandas as pd
from exa import Parser, TypedProperty, DataFrame, LazyFunction
from exa.tex import text_value_cleaner
from exatomic.nwchem.nwpw.psp.grid import scaled_logspace


class PAWOutput(Parser):
    """
    Parser for debug output files generated by NWChem's on-the-fly pseudopotential
    generation code.
    """
    _key_delims = (" Atom information :", " Logarithmic grid information ( r(i)=r0*pow(a,i) )",
                   " Compensation charge information :", " Paw potential information :",
                   " Basis information :", " Core information :")
    data = TypedProperty(DataFrame, docs="Pseudized waves")
    grid = TypedProperty(LazyFunction, docs="Radial grid function")

    def _parse(self):
        """Identify and process the output file from text to data objects."""
        self.meta = {}
        self.data = DataFrame()
        sections = self.find(*self._key_delims, text=False)
        for section, start in sections.items():
            if section == " Paw potential information :":
                self._key_subsection_parsers[section](start[0]+1, delnl=True)
            else:
                self._key_subsection_parsers[section](start[0]+1)

    def _parse_meta_like(self, start, save=True):
        """Function to parse 'key delimiter value' lines of the output."""
        sep = ':' if ':' in self[start+1] else "="
        k = 0
        dct = {}
        for line in self[start:]:
            if sep not in line:
                k += 1
                if k == 2:
                    break
            else:
                key, value = line.split(sep)
                dct[key.strip()] = text_value_cleaner(value)
        if save:
            self.meta.update(dct)
        else:
            return dct

    def _parse_grid(self, start):
        """Parse the arguments to the grid function."""
        grid = self._parse_meta_like(start, save=False)
        self.grid = LazyFunction(scaled_logspace, grid['r0'], grid['a'], grid['N'])

    def _parse_paw(self, start, delnl=False):
        """Parse the PAW potential and basis information."""
        m = len(self.meta)
        self._parse_meta_like(start)
        n = len(self.meta)
        k = start + n - m + 2
        l = 0
        for line in self[k:]:
            if line == "":
                break
            l += 1
        df = self[k:k+l].to_data(delim_whitespace=True)
        if delnl:
            del df['nl']
        self._merge_df(df)

    def _merge_df(self, df):
        if len(self.data) == 0:
            self.data = df
        else:
            self.data = pd.concat((self.data, df), axis=1)
        if 'nl' in self.data.columns:
            self.data['nl'] = self.data['nl'].str.upper()

    def __init__(self, *args, **kwargs):
        super(PAWOutput, self).__init__(*args, **kwargs)
        self._key_parsers = (self._parse_meta_like, self._parse_grid,
                             self._parse_meta_like, self._parse_paw,
                             self._parse_paw, self._parse_meta_like)
        self._key_subsection_parsers = dict(zip(self._key_delims, self._key_parsers))
